Executive Summary:

Assignment Overview:
This assignment focused on the design and development of a distributed system that enables communication between clients and a server using TCP and UDP connections.
The goal was to gain practical experience in distributed systems, particularly in the areas of logging, error mechanisms, and the differences between TCP and UDP protocols.
The scope of the assignment included implementing a TCP server and client, as well as a UDP server and client. The servers were needed to handle a single client connection, supporting commands for key-value storage such as GET, PUT, DELETE. It required robust error handling mechanisms to handle errors like IO and Timeout and provide meaningful feedback to clients.
Logging functionality was also incorporated to capture important information for monitoring and debugging purposes. The UDP server and client had similar objectives, but with the key distinction of using a connectionless protocol for UDP. Logging played a crucial role in both the TCP and UDP implementations. It provided a means to track the connections established, commands received, and responses sent.
Logging allowed for effective monitoring and debugging of the distributed system, enabling the identification and resolution of potential issues.
The experience gained through this assignment will serve as a foundation for future network programming tasks and deepen our understanding of network protocols and communication systems within the context of distributed systems.

Technical Impression:
Throughout the assignment, I successfully developed both TCP and UDP server-client communication systems. I implemented the TCP server to handle a single client connection, allowing client to send commands and interact with the key-value store. The server performed the requested operations and sent appropriate responses back to the clients. I also implemented error handling to handle IO errors, connection errors, and invalid commands.
On the client side, I created TCP and UDP clients that establish connections with the respective servers and send commands. The clients received responses from the servers and logged relevant information about the connection, commands, and received data. I also ensured that error handling was in place on the client side to handle IO errors and connection timeouts. Furthermore, if client sent an invalid command or a wrong key, there were mechanisms in place to prevent crashing the server and sending an appropriate message back to the client.
The assignment provided valuable experience in understanding socket programming, TCP and UDP protocols, client-server communication, error handling, and logging. It also allowed me to explore the differences between TCP and UDP in terms of reliability, connection-oriented versus connectionless communication, and performance considerations.
One major challenge was designing error handling mechanisms for both the server and client sides. I had to consider various scenarios such as IO errors, connection timeouts, and invalid commands / Keys. Implementing robust error handling required thorough error detection and appropriate error messages to provide meaningful feedback to clients and maintain the integrity of the system. Incorporating timeout mechanisms for connection establishment and data transmission added an extra layer of complexity, requiring careful consideration of timing and response handling.
Additionally, incorporating logging functionality posed a challenge. I needed to log relevant information about connections, commands, and received data while ensuring the logs were organized, easily readable, and provided valuable insights for debugging and monitoring purposes. Extracting the client info from the packet received and balancing the level of detail in the logs and optimizing the logging process without negatively impacting performance was a task that required careful consideration.
In future considerations, one way to enhance the assignment would be to update the TCP / UDP server implementation to support multiple clients using threads and concurrency. Currently, the server handles one client connection at a time, which limits its scalability and responsiveness. By introducing multi-threading, each client connection could be processed independently, allowing concurrent interactions and improving the overall performance of the system. This would involve creating a thread pool to manage client requests, ensuring thread safety when accessing shared resources, and implementing appropriate synchronization mechanisms.
Additionally, incorporating load balancing techniques could distribute the client connections across multiple server instances, further enhancing the system's scalability and fault tolerance. By introducing these advanced concepts, the assignment could provide a more comprehensive understanding of building distributed systems that can efficiently handle concurrent client interactions.
In conclusion, this assignment provided valuable hands-on experience in developing distributed systems. The technical challenges encountered allowed us to deepen my understanding of concepts such as error handling, and logging in distributed systems. We gained practical knowledge in implementing TCP and UDP communication, handling client connections, and managing errors and timeouts effectively. The experience gained through this assignment will serve as a foundation for future network programming tasks and deepen our understanding of network protocols and communication systems.